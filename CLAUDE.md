# Claude Code Setup

This repository uses the `.arch` framework for spec-driven development with architect and implementer agents.

## Quick Start

### For New Sessions (Sprint Resume)

1. **Check active sprint**: Read [.arch/sprints/current.md](.arch/sprints/current.md) for sprint overview
2. **Read sprint context**: See sprint's `CONTEXT.md` for database, architecture, and patterns
3. **Check wave status**: Review sprint's `WAVE-STATUS.md` for current progress
4. **Continue work**: Use `/start-sprint-wave N M` to launch next wave or claim individual RFCs

### For Sprint Planning

1. **Read the workflow**: See [.arch/README.md](.arch/README.md) for complete workflow
2. **Read sprint planning guide**: See [.arch/sprints/SPRINT-PLANNING-GUIDE.md](.arch/sprints/SPRINT-PLANNING-GUIDE.md)
3. **Initialize sprint**: Use `/init-sprint N` to auto-generate wave plan and context
4. **Review example**: See [.arch/sprints/example-sprint.md](.arch/sprints/example-sprint.md) for complete example

### Available Commands

- `/init-sprint N` - Initialize sprint with approved RFCs, generate context and wave plan
- `/start-sprint-wave N M` - Launch parallel agents for all RFCs in wave M of sprint N
- `/update-sprint-context N` - Update context files with latest changes
- `/claim-rfc X` - Claim and start work on RFC
- `/complete-rfc X` - Mark RFC as complete
- `/sprint-status` - View overall sprint progress

## Architecture

The `.arch/` directory contains:
- **rfcs/**: Feature requests organized by status (pending → approved → in-progress → implemented)
- **agents/**: Architect and implementer agent templates
- **sprints/**: Sprint planning and tracking
- **decisions/**: Architectural Decision Records (ADRs)

## Best Practices

### For Architects
- Review RFCs and assign parallelization waves based on dependencies
- Create comprehensive sprint context files (CONTEXT.md with database, architecture, patterns)
- Update context files when architecture changes
- Use `/init-sprint` to auto-generate dependency graph and wave assignments
- Monitor wave execution and approve wave transitions

### For Implementers
- **ALWAYS read sprint CONTEXT.md first** - it contains database, architecture, and code patterns
- Read RFC specification and dependency graph before starting
- Claim RFC with `/claim-rfc`, implement following patterns from CONTEXT.md, complete with `/complete-rfc`
- Update WAVE-STATUS.md regularly with progress
- Write tests following testing patterns from context

### For Sprint Coordination
- Initialize sprints with `/init-sprint N` for automatic wave planning
- Launch waves with `/start-sprint-wave N M` for parallel execution
- One wave at a time - complete Wave N before starting Wave N+1
- Update context between waves with `/update-sprint-context N`

### Critical: Context Files Prevent Context Loss

**Problem**: Parallel agents run in separate Claude sessions with no conversation history.

**Solution**: Comprehensive context files that agents read before starting work:

#### Sprint Context Files

Every sprint should have (auto-generated by `/init-sprint`):

1. **`sprint-N/CONTEXT.md`** - Complete project context:
   - Database schema with examples
   - Architecture patterns with code snippets
   - API contracts with request/response examples
   - Testing patterns and requirements
   - Common gotchas and solutions
   - **This is the PRIMARY context source for all agents**

2. **`sprint-N/DEPENDENCY-GRAPH.md`** - Visual RFC dependencies:
   - Mermaid diagram of dependencies
   - Wave assignments and reasoning
   - Critical path analysis
   - Time savings calculation

3. **`sprint-N/WAVE-STATUS.md`** - Real-time execution tracking:
   - Current wave status
   - RFC progress (pending, in-progress, completed)
   - Agent assignments
   - Blockers and issues

#### Why Context Files Matter

Without comprehensive context:
- ❌ Agents guess at patterns → inconsistent code
- ❌ Agents ask questions → delays and context switches
- ❌ Agents miss dependencies → broken implementations
- ❌ Agents don't follow architecture → technical debt

With comprehensive context:
- ✅ Agents implement correctly first time
- ✅ Agents work independently without questions
- ✅ Agents follow established patterns
- ✅ True parallelization achieved

**Example**: [.arch/sprints/example-sprint/CONTEXT.md](.arch/sprints/example-sprint/CONTEXT.md) shows a complete context file that enabled 32% time savings through parallelization.

### Wave-Based Parallel Execution

**Automated with `/init-sprint`** - Analyzes RFC dependencies and creates wave plan:

```
Wave 1 (no dependencies - parallel):
  RFC-001: Database Schema (4h)
  RFC-002: Auth Service (5h)
  → Duration: 5h (max of both)

Wave 2 (depends on Wave 1 - parallel):
  RFC-003: Product Service (5h, needs RFC-001)
  RFC-004: User Profile (3h, needs RFC-001, RFC-002)
  → Duration: 5h (max of both)

Wave 3 (depends on Wave 2):
  RFC-005: Shopping Cart (6h, needs RFC-003, RFC-004)
  → Duration: 6h

Total: 16h parallel vs 23h sequential = 30% faster
```

**Execution**:
```bash
/init-sprint 1              # Creates wave plan + context
/start-sprint-wave 1 1      # Launches RFC-001 & RFC-002 in parallel
# Wait for Wave 1 completion
/start-sprint-wave 1 2      # Launches RFC-003 & RFC-004 in parallel
# Wait for Wave 2 completion
/start-sprint-wave 1 3      # Launches RFC-005
```

**Key**: Launch ALL wave RFCs in **one message** using multiple Task tool calls for true parallelization.

## Customization

Add project-specific guidance below:

---

<!-- Add your project-specific instructions here -->
